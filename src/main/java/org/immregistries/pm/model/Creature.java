package org.immregistries.pm.model;

import org.immregistries.pm.servlet.TestMatchingServlet;

/**
 * Represents a "creature" that exists within the optimization world. The creature
 * has a set of weights that are the creatures "DNA" and describe how the creature
 * finds matches. The associated score is how well the creature performs on a 
 * given test set. 
 * @author Nathan Bunker
 *
 */
public class Creature {

  private int generation = 0;
  private Scorer scorer = null;
  private World world = null;
  private PatientCompare patientCompare;
  private boolean scored = false;
  private double score = 0;

  /**
   * @return <code>true</code> if creature has already been scored and does not need to be scored again
   */
  public boolean isScored() {
    return scored;
  }

  public void setScored(boolean scored) {
    this.scored = scored;
  }

  /**
   * @return scorer object that gives details on how score was derived
   */
  public Scorer getScorer() {
    return scorer;
  }

  /**
   * @return underlying patient compare object with patient data in it
   */
  public PatientCompare getPatientCompare() {
    return patientCompare;
  }

  /**
   * @return generation that this creature was born
   */
  public int getGeneration() {
    return generation;
  }
  
  /**
   * @param generation indicates the generation this creature was born
   */
  public void setGeneration(int generation)
  {
    this.generation = generation;
  }

  /**
   * Creates new creature, this is where a creature is born.
   * @param generation indicates the current generation, the generation when this creature was bgorn
   * @param world the world that this creature is born into
   */
  public Creature(int generation, World world) {
    this.generation = generation;
    this.world = world;
    patientCompare = new PatientCompare();
    scorer = new Scorer();
  }
  
  /**
   * @param world recreates creature that has already been born based on the script of that creature.
   * @param script script that was generated by original creature
   */
  public Creature(World world, String script) {
    this.world = world;
    patientCompare = new PatientCompare();
    this.generation = patientCompare.readScript(script);
    scorer = new Scorer();
  }
  
  /**
   * Setups up current creature to be like creature defined in script.
   * @param script script that was generated by original creature
   */
  public void readScript(String script)
  {
    this.generation = patientCompare.readScript(script);
  }
  
  /**
   * @return script for creating creature again
   */
  public String makeScript()
  {
    return "Generation:" + generation + ";" + "World Name:" + world.getWorldName() + ";" + "Island Name:" + world.getIslandName() + ";" + "Score:" + score + ";"   + patientCompare.makeScript();
  }

  public String toString() {
    return "Generation: " + generation + " Match: " + patientCompare.getMatch() + " Not Match: " + patientCompare.getNotMatch() + " Twin: "
        + patientCompare.getTwin() + " Missing: " + patientCompare.getMissing();
  }

  /**
   * Access method to request that the creature randomize its own weights.
   */
  public void randomize() {
    patientCompare.getMatch().makeRandom();
    patientCompare.getNotMatch().makeRandom();
    patientCompare.getTwin().makeRandom();
    patientCompare.getMissing().makeRandom();
  }

  /**
   * This is a critical step where a new creature is created from the union of two parent creatures.
   * The new creature has a new generation and shares characteristics randomly selected from 
   * either parent. 
   * @param generation indicates the current generation
   * @param parentA  the first parent for the new child
   * @param parentB  the second parent for the new child
   */
  public Creature(int generation, Creature parentA, Creature parentB) {
    this.generation = generation;
    this.world = parentA.world;
    patientCompare = new PatientCompare();
    patientCompare.getMatch().mate(parentA.patientCompare.getMatch(), parentB.patientCompare.getMatch());
    patientCompare.getNotMatch().mate(parentA.patientCompare.getNotMatch(), parentB.patientCompare.getNotMatch());
    patientCompare.getTwin().mate(parentA.patientCompare.getTwin(), parentB.patientCompare.getTwin());
    patientCompare.getMissing().mate(parentA.patientCompare.getMissing(), parentB.patientCompare.getMissing());
    scorer = new Scorer();
  }

  @Override
  public int hashCode() {
    return ("" + patientCompare.getMatch().hashCode() + patientCompare.getNotMatch().hashCode() + patientCompare.getTwin().hashCode() + patientCompare
        .getMissing().hashCode()).hashCode();
  }

  /**
   * Creates a copy of the creature. Sometimes instead of mating two creatures together the optimization algorithm
   * makes a copy and then tweaks it to make a new generation.  
   * @param generation
   * @param clone
   */
  public Creature(int generation, Creature clone) {
    this.generation = generation;
    this.world = clone.world;
    patientCompare = new PatientCompare();
    patientCompare.getMatch().clone(clone.patientCompare.getMatch());
    patientCompare.getNotMatch().clone(clone.patientCompare.getNotMatch());
    patientCompare.getTwin().clone(clone.patientCompare.getTwin());
    patientCompare.getMissing().clone(clone.patientCompare.getTwin());
    scorer = new Scorer();
  }

  /**
   * Scores the list of patients in the match sets and creates overall score. 
   * Retrieve score using getScore(). 
   */
  public void score() {
    scorer = new Scorer();
    for (MatchItem matchItem : world.getMatchItemList()) {
      if (matchItem.isExpectedStatusSet()) {
        patientCompare.setMatchItem(matchItem);
        scorer.registerMatch(matchItem, patientCompare);
      }
    }
    score = scorer.getScore();
    scored = true;
  }

  /**
   * @return score generated by score() method
   */
  public double getScore() {
    return score;
  }

  /**
   * 
   * @param potentialMate
   * @return <code>true</code> if potentialMate has the same DNA
   */
  public boolean isSame(Creature potentialMate) {
    return patientCompare.getMatch().isSame(potentialMate.getPatientCompare().getMatch())
        && patientCompare.getNotMatch().isSame(potentialMate.getPatientCompare().getNotMatch())
        && patientCompare.getTwin().isSame(potentialMate.getPatientCompare().getTwin())
        && patientCompare.getMissing().isSame(potentialMate.getPatientCompare().getMissing());
  }

  public static void main(String[] args) {
    World world = new World(30, "main", "");
    Creature c1 = new Creature(1, world);
    System.out.println("c1 = " + c1);
    Creature c2 = new Creature(1, world);
    System.out.println("c2 = " + c2);
    System.out.println("c1 == c2 " + (c1.isSame(c2)));
    System.out.println("Randomize");
    c1.randomize();
    System.out.println("c1 = " + c1);
    System.out.println("Clone & Mutate");
    c1.randomize();
    c2 = new Creature(2, c2);
    c2.mutate();
    System.out.println("c2 = " + c2);
  }
  
  /**
   * Modifies the DNA of each match state so that the values are slightly different (by about 10%) from the
   * current values. Tweaking assumes that the right answer is probably close to the best answers we have
   * already and preference should be made for searching the nearby vicinity for a better solution. 
   */
  public void tweak()
  {
    patientCompare.getMatch().tweak();
    patientCompare.getNotMatch().tweak();
    patientCompare.getTwin().tweak();
    patientCompare.getMissing().tweak();
    
  }

  /**
    * Randomly mutates or changes certain DNA, similar to radiation messing up DNA in biology. 
    * Mutations are more common at first but reduce linearly with the number of generations.
    * In later generations mutations become rarer.   
   */
  public void mutate() {
    patientCompare.getMatch().mutate(generation);
    patientCompare.getNotMatch().mutate(generation);
    patientCompare.getTwin().mutate(generation);
    patientCompare.getMissing().mutate(generation);
  }

}
